/*
Package dependencyinjection provides the basic DI stuff

inject tags:

	type foo struct {
		Dependency `inject:""`
	}

Dependency-Types:

Named:
	lookup in named

Inline:
	the struct will be handled on it's own.
	has to be set to ensure that no dependencies are created which should have been a pointer to a shared dependency

Unnamed:
Function:
	Factory-function which wraps the result in a new resolve-call

Pointer to struct:
	Cached instance if available
	New-created and cached if not available

Interface:
	Cached and appliable, but not autogenerated values
	Fails if multiple possibilities apply

Private:
Pointer to struct:
	The structs is generated on the fly

Interface:
	A factory is used to retrieve the proper dependency

*/
package dependencyinjection

import (
	"fmt"
	"log"
	"reflect"
)

type (
	// Object represents a object which we work with
	// essentially it wraps value and tags, and some internal flags
	Object struct {
		Value interface{} // Value points to the original value
		Tags  []string    // Tags hold a list off assigned tags

		complete       bool          // complete will be set to true when the object has been properly resolved
		autocreated    bool          // autocreated signals objects which have been created, so they are not used for interface injection
		compilerpassed bool          // compilerpassed makes sure compiler pass happens only once
		reflectType    reflect.Type  // reflectType is a cache for reflect.TypeOf(Value)
		reflectValue   reflect.Value // reflectValue is a cache for reflect.ValueOf(Value)
		wrapFunc       reflect.Value // wrapFunc is generated for functions types, and wrap their argument into a new resolve call
	}

	// Container is our service-dependency-injection-container which holds a list of
	// - all named objects
	// - all tagged objects
	// - all factories
	// - all cached objects
	Container struct {
		named   map[string]*Object
		tags    map[string][]*Object
		factory map[reflect.Type]*Object
		cache   map[reflect.Type]*Object
	}

	// CompilerPasser is called whenever an object has been created
	CompilerPasser interface {
		CompilerPass(c *Container) // CompilerPass gives access to a temporary container (just tags assigned)
	}

	// RegisterFunc is used for registration callbacks
	RegisterFunc func(c *Container)
)

// NewContainer creates a new, empty container
func NewContainer() *Container {
	var container = &Container{
		named:   make(map[string]*Object),
		tags:    make(map[string][]*Object),
		factory: make(map[reflect.Type]*Object),
		cache:   make(map[reflect.Type]*Object),
	}

	container.Register(container)

	return container
}

// resolve resolves all object dependencies
func (sc *Container) resolve(object *Object) {
	var objectlist []*Object
	var i int
	var tmptags = make(map[string][]*Object)
	var cache = make(map[reflect.Type]*Object)

	objectlist = append(objectlist, object)

	for {
		i++
		if i > len(objectlist) {
			break
		}
		current := objectlist[i-1]

		if current.complete {
			continue
		}

		current.complete = true
		current.reflectType = reflect.TypeOf(current.Value)
		current.reflectValue = reflect.ValueOf(current.Value)

		cache[current.reflectType] = current

		// check object type
		switch current.reflectType.Kind() {
		case reflect.Func:
			// we can not resolve anything for a func
			continue

		case reflect.Ptr:
			// we have a proper pointer :)
			break

		default:
			panic(fmt.Sprintf("Logic: Can not resolve a concrete instance of %s", current.reflectType))
		}

		// go thru each field
		for fieldIndex := 0; fieldIndex < current.reflectValue.Elem().NumField(); fieldIndex++ {
			field := current.reflectValue.Elem().Field(fieldIndex)
			tagval, ok := current.reflectType.Elem().Field(fieldIndex).Tag.Lookup("inject")

			if !ok {
				continue
			}

			switch tagval {
			case "private":
				// private injection
				switch field.Type().Kind() {
				case reflect.Interface:
					// private interfaces have to be factorized
					if factory, ok := sc.factory[field.Type()]; ok {
						newObject := &Object{
							Value: factory.reflectValue.Call([]reflect.Value{})[0].Interface(),
						}
						for _, tag := range factory.Tags {
							tmptags[tag] = append(tmptags[tag], newObject)
						}
						field.Set(reflect.ValueOf(newObject.Value))
						objectlist = append(objectlist, newObject)
						continue
					}
					panic(fmt.Sprintf("no factory for %s of %s", field.Type(), current.reflectType))

				case reflect.Ptr:
					// private pointer are generated
					newObject := &Object{
						Value: reflect.New(field.Type().Elem()).Interface(),
					}

					field.Set(reflect.ValueOf(newObject.Value))
					objectlist = append(objectlist, newObject)

				default:
					panic(fmt.Sprintf("cannot create a private dependency for %s of %s", field.Type(), current.reflectType))
				}

			case "inline":
				// inline injection
				objectlist = append(objectlist, &Object{Value: field.Addr().Interface()})

			case "":
				// unnamed injection

				// functions are handled with their wrapFunc
				if field.Type().Kind() == reflect.Func {
					if cache, ok := sc.cache[field.Type()]; ok {
						field.Set(cache.wrapFunc)
						continue
					}
					panic(fmt.Sprintf("Cannot find function %s for %s", field.Type(), current.reflectType))
				}

				// Interfaces are assigned if we have an aissngable, not autocreated object
				if field.Type().Kind() == reflect.Interface {
					var assigned bool
					for cachetype, cached := range cache {
						if cachetype.AssignableTo(field.Type()) && !cached.autocreated {
							log.Println(cachetype, field.Type())
							if assigned {
								panic(fmt.Sprintf("found more than one assignable in local cache value for %s field %s", current.reflectType, field.Type()))
							}
							assigned = true
							field.Set(reflect.ValueOf(cached.Value))
							objectlist = append(objectlist, cached)
						}
					}
					if assigned {
						continue
					}
					for _, cached := range sc.cache {
						if reflect.TypeOf(cached.Value).AssignableTo(field.Type()) && !cached.autocreated {
							if assigned {
								panic(fmt.Sprintf("found more than one assignable value for %s field %s", current.reflectType, field.Type()))
							}
							assigned = true
							field.Set(reflect.ValueOf(cached.Value))
							objectlist = append(objectlist, cached)
						}
					}
					if !assigned {
						panic(fmt.Sprintf("found no assignable value for %s field %s", current.reflectType, field.Type()))
					}
					continue
				}

				// everything non-pointer can not be handled any further
				if field.Type().Kind() != reflect.Ptr {
					panic(fmt.Sprintf("Cannot inject into unnamed non-pointer: %s in %s", field.Type(), current.reflectType))
				}

				// cache is checked
				if cache, ok := cache[field.Type().Elem()]; ok {
					field.Set(reflect.ValueOf(cache.Value))
					objectlist = append(objectlist, cache)
					continue
				}

				// cache is checked
				if cache, ok := sc.cache[field.Type().Elem()]; ok {
					field.Set(reflect.ValueOf(cache.Value))
					objectlist = append(objectlist, cache)
					continue
				}

				// new object is created
				newObject := &Object{
					Value:       reflect.New(field.Type().Elem()).Interface(),
					autocreated: true,
				}

				field.Set(reflect.ValueOf(newObject.Value))
				objectlist = append(objectlist, newObject)

				sc.cache[field.Type().Elem()] = newObject

			default:
				// named injection
				if named, ok := sc.named[tagval]; ok {
					field.Set(reflect.ValueOf(named.Value))
					if !named.complete {
						objectlist = append(objectlist, named)
					}
					continue
				}
				panic("named value " + tagval + " not found")
			}
		}
	}

	// now we do the compilerpass by creating a new container with a list of all tagged objects
	// and pass that on to all CompilerPasser
	var newContainer = NewContainer()
	for tag, list := range tmptags {
		newContainer.tags[tag] = append(newContainer.tags[tag], list...)
	}
	for tag, list := range sc.tags {
		newContainer.tags[tag] = append(newContainer.tags[tag], list...)
	}
	for _, current := range objectlist {
		if cp, ok := current.Value.(CompilerPasser); ok && !current.compilerpassed {
			current.compilerpassed = true
			cp.CompilerPass(newContainer)
		}
	}
}

// Get a named service
func (sc *Container) Get(key string) interface{} {
	if object, ok := sc.named[key]; ok {
		sc.resolve(object)
		return object.Value
	}
	panic(key + " not found")
}

// GetTagged returns list of tagged services
func (sc *Container) GetTagged(tag string) []*Object {
	for _, o := range sc.tags[tag] {
		sc.resolve(o)
	}
	return sc.tags[tag]
}

func (sc *Container) wrapFunc(function reflect.Value) func(args []reflect.Value) []reflect.Value {
	return func(args []reflect.Value) []reflect.Value {
		result := function.Call(args)
		if len(result) == 1 {
			sc.resolve(&Object{Value: result[0].Interface()})
		}
		return result
	}
}

// Register a service
func (sc *Container) Register(object interface{}, tags ...string) {
	var o = &Object{Value: object, Tags: tags}
	var reflectType = reflect.TypeOf(object)

	if reflectType.Kind() == reflect.Func {
		// for functions we create a wrapper which lazy-calls resolves the functions result
		// currently works for only one-result functions
		if reflectType.NumOut() > 1 {
			panic("can not handle more than 1 result! %s" + o.reflectType.String())
		}
		sc.resolve(o)
		o.wrapFunc = reflect.MakeFunc(
			o.reflectType,
			sc.wrapFunc(o.reflectValue),
		)
	}

	if reflectType.Kind() == reflect.Ptr {
		sc.cache[reflect.TypeOf(object).Elem()] = o
	} else {
		sc.cache[reflect.TypeOf(object)] = o
	}

	for _, tag := range tags {
		sc.tags[tag] = append(sc.tags[tag], o)
	}
}

// RegisterNamed register a service with an explicit name
func (sc *Container) RegisterNamed(name string, object interface{}, tags ...string) {
	o := &Object{
		Value: object,
		Tags:  tags,
	}

	sc.named[name] = o

	for _, tag := range tags {
		sc.tags[tag] = append(sc.tags[tag], o)
	}

	if reflect.TypeOf(object).Kind() == reflect.Func {
		// for functions we create a wrapper which lazy-calls resolves the functions result
		// currently works for only one-result functions
		if reflect.TypeOf(object).NumOut() > 1 {
			panic("can not handle more than 1 result! %s" + o.reflectType.String())
		}
		sc.resolve(o)
		o.wrapFunc = reflect.MakeFunc(
			o.reflectType,
			sc.wrapFunc(o.reflectValue),
		)
	}
}

// RegisterFactory registers a factory for a given type
func (sc *Container) RegisterFactory(factory interface{}, tags ...string) {
	o := &Object{Value: factory, Tags: tags}
	sc.resolve(o)
	sc.factory[reflect.TypeOf(factory).Out(0)] = o
}

// Resolve resolves dependencies for one single object
func (sc *Container) Resolve(object interface{}) {
	sc.resolve(&Object{Value: object})
}
