# Flamingo Frontend Development

In this document you will find anything necessary to get started in developing the flamingo frontend.

## Frontend build pipeline

### Webpack

flamingo uses [webpack](https://webpack.js.org/) for packing frontend modules into a few bundled assets
which are then eventually served to the end-user.

The webpack configuration resides in `akl/frontend/build` and is separated into three files:

- `webpack.base.conf.js` (contains the base configuration)
- `webpack.development.conf.js` (inherits from base configuration and overrides it with development specific configuration)
- `webpack.production.conf.js` (inherits from base configuration and overrides it with production specific configuration)

webpack basically performs the following tasks:

- transpiling ES6 code (including .vue files) into ES5 code using babel
- compiling [Sass](http://sass-lang.com/) code into CSS
- creating source map files in development environment
- bundling all assets into minified production ready assets in production environment

### Yarn

flamingo uses [yarn](https://yarnpkg.com) for frontend dependency management and as a task runner.
To list all awailable tasks, do the following:

```sh
cd akl/frontend
yarn run
```

Please get familiar with yarn and especially with how it handles [dependency locking](https://yarnpkg.com/lang/en/docs/yarn-lock/).

### Main build tasks

After `cd`ing into the frontend folder you can execute all frontend build tasks using the following command:

```sh
yarn run <task>
```

#### `build:assets`

Creates dist directories and executes webpack using either development or production configuration.

#### `build:templates`

Compiles [Pug](https://pugjs.org) source inside `akl/frontend/src/templates` folder and generates HTML files served by the dev-server,
as well as an abstract syntax tree (AST) which is used for the generation of Go-templates. Please get familiar with Pug.

#### `build:styleguide`

Generates a “living” styleguide from source.

#### `dev`

Starts the frontend development server, which serves the HTML files generated by the `build:templates` task.

#### `dev:mockserver`

Same as dev, but with the environment variable `USE_MOCK_SERVER` set to `true`. See [mocking](#mocking).

## Mocking

For quick and independent frontend development flamingo offers a mocking concept.
You can write and register mock files in JSON and consume those inside the template files
respectively replicate in the backend. They kind of serve as “contract” between front- and backend.

The following schema exemplarily illustrates how the flamingo components work together within the scope of an MVC-design:

```
Product Controller (executes on a predefined route)       ┌────────────────→  Brand Block Contoller  ─────────┐
  |         |                                             |                             |                     |
  |   interacts with                                      |                       interacts with        returns data
  |         ↓                                             |                             ↓                     |
  |   Product Model  ────┐                          requests data                 Product Model  ────┐        |
  |                      |                                |                                          |        |
  |                     uses                              |                                         uses      |
  |                      |                                |                                          |        |
  └─────  calls  ────────|────→  Product View (Go-template generated from Pug-template)  ←───────────|────────┘
                         |                                                                           |
.........................|...........................................................................|..............
                         |                                                                           |
                         └───────────────────────→  mock data (JSON)  ←──────────────────────────────┘
                                                          ↑
                                                         uses
                                                          |
                                              Product View (Pug-template)

```

## Tutorial

In this tutorial you will lern how to pass data to the templates from mock files (you’ll work below the dotted line)
and from an actual controller (you’ll work below and above the dotted line).

### “What time is it?”

Create a new page `whattime.pug` inside `akl/frontend/src/templates/pages`:

```pug
extends /layouts/default
block content
  - message = message || 'It’s time!'
  h1= __('Current time: %s - %s', get('whattime').now, message)
```

Then create a new mock file `whattime.json` for that page inside `akl/frontend/src/mocks`:

```json
{
  "now": "Thu Jun 29 2017 17:34:04 GMT+0200 (CEST)"
}
```

Add a new mock-page-mapping in `akl/frontend/src/mocks/_mockmap.js`:

```js
module.exports = {
  'pages/whattime.pug': {
    'whattime': 'whattime'
  }
}
```

Compile the templates:

```sh
yarn run build:templates
```

Start the dev server:

```sh
yarn run dev
```

Now navigate to [http://localhost:1337/whattime.html](http://localhost:1337/whattime.html)

You should see a page which prints “Current time: Thu Jun 29 2017 17:34:04 GMT+0200 (CEST) - It’s time!”.

The mock data is currently read from the mock files directly and servered by the Node dev server.
If you reload the page, the time stays the same.
And this is actually all you need for frontend development.

Just to get an idea of what’s going on above the dotted line, let’s get the mock data from the mock server.

Register the route for our whattime view in `akl/config/context.yml`:

```yaml
routes:
  # default index page
  - path: /
    controller: flamingo.render(tpl="pages/home")
    name: home
  # whattime page
  - path: /whattime
    controller: flamingo.render(tpl="pages/whattime")
    name: whattime
```

Restart the dev server with the environment variable `USE_MOCK_SERVER` set to `true` using the following command:

```sh
yarn run dev:mockserver
```

The mock data will now be requested from the mock server, which we start up inside the `akl/` directory:

```sh
export CONTEXT="dev" && go run akl.go serve
```

Now navigate to [http://localhost:3210/en/whattime](http://localhost:3210/en/whattime)

You should see a page which prints “Current time: Thu Jun 29 2017 17:34:04 GMT+0200 (CEST) - It’s time!”.
Yes, it also renders the mocked data with the default message.

Next, we want to have a controller, which overrides the mocked data with “real” data.
Create a `whattime` module in `akl` by creating a folder `akl/src/whattime` similarly as in the Hello World tutorial.
Remove the route for our whattime view in `akl/config/context.yml`.
The new index controller in the whattime module will now do that job.
Here is how we structure the whattime module:

```
├─ whattime
|   ├─ interfaces
|   |   └─ controller
|   |       ├─ data.go
|   |       └─ index.go
|   └─ module.go
```

In module.go we configure the index controller and the data controller. It should look like this:

```go
package whattime

import (
	"flamingo/akl/src/whattime/interfaces/controller"
	"flamingo/framework/dingo"
	"flamingo/framework/router"
)

type Module struct {
	RouterRegistry *router.Registry `inject:""`
}

func (m *Module) Configure(injector *dingo.Injector) {
	m.RouterRegistry.Route("/whattime", "whattime.index")
	m.RouterRegistry.Handle("whattime.index", new(controller.IndexController))
	m.RouterRegistry.Handle("whattime", new(controller.DataController))
}
```

In `data.go` we implement the property now which will be accessed via `get('whattime').now`. It should look like this:

```go
package controller

import (
	"flamingo/framework/web"
	"time"
)

type (
	DataController struct {}
)

func (controller *DataController) Data(ctx web.Context) interface {} {
	return struct{Now string}{Now: time.Now().String()}
}
```

Our index controller (`index.go`) will pass a random message to our `whattime` template, it should look like this:

```go
package controller

import (
	"flamingo/framework/web"
	"flamingo/framework/web/responder"
	"math/rand"
)

// IndexController to handle /whattime
type (
	IndexController struct {
		responder.RenderAware `inject:""`
	}
)

// Get handles our GET requests
func (controller *IndexController) Get(ctx web.Context) web.Response {
	if rand.Intn(10)%2 == 0 {
		return controller.Render(ctx, "pages/whattime", struct{ Message string }{Message: "Hurry!"})
	}
	return controller.Render(ctx, "pages/whattime", struct{Message string}{Message: "Relax!"})
}
```

Restart the server:

```sh
export CONTEXT="dev" && go run akl.go serve
```

Now navigate to [http://localhost:3210/en/whattime](http://localhost:3210/en/whattime) and reload the page a few times.

You should see a page which prints the current time and either “Hurry!” or “Relax!” randomly on each page reload.

As a final step, let’s implement a whattime Pug mixin which we use inside the whattime page template.
Create the file `whattime.pug` inside the folder `akl/frontend/src/templates/mixins/` with the following content:

```pug
mixin whattime(msg)
  - msg = msg || 'It’s time!'
  h1= __('Current time: %s - %s', get('whattime').now, msg)
```

Include it in `akl/frontend/src/templates/mixins/index.pug`:

```pug
include whattime
```

Change the content of `akl/frontend/src/templates/pages/whattime.pug` so that it looks like this:

```pug
extends /layouts/default
block content
  +whattime(message)
  hr
  +whattime(message)
```

Again, navigate to [http://localhost:1337/whattime.html](http://localhost:1337/whattime.html)

You should see a page which prints “Current time: Thu Jun 29 2017 17:34:04 GMT+0200 (CEST) - It’s time!” twice.

Compile the templates:

```sh
yarn run build:templates
```

Make sure the flamingo server still runs and navigate to [http://localhost:3210/whattime](http://localhost:3210/whattime)
Reload the page a few times.

You should see a page which prints the current time twice with minor differences
and either 2x “Hurry!” or 2x “Relax!” randomly on each page reload.

Done.
